<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <!-- 'hello'+ arr + 'world' -->
  <div id="app"  style="border: 1px;font-size: 18px;">
    hello{{name}}world{{age}}
  </div>
  <script src="dist/vue.js"></script>  

  <script>
    // viewModel 数据模型
    // 典型的MVVM  view vm  model
    let vm = new Vue({
      el: '#app',
      data: {
        name: 'feng',
        a: {
          a: 1
        },
        age: [11, 12, 13],
        arr: [[1,2,3]],
        friends: '',
        arr: [{name: 'cj'}, {name: 'feng'}]
      }
    })
    // 新增的属性不能监听,只能监听已有属性
    vm._data.a.b = 1
    // 新增的属性为对象可以被监听
    vm._data.a = {...vm._data.a, c:1}
    vm.friends = 'bingbing'
    console.log(vm, 'vm')
    // 用户很少通过索引操作数组 arr[82] = 1000 内部不对索引进行拦截,因为消耗严重,内部数组不采用defineProperty
    // 更改7个数组方法 push shift pop unshift reverse sort splice

    // 数组没有监控索引变化, 但是索引对应的内容是对象类型,需要被监控
    vm.arr[0].name
    //  数据变化需要影响视图，数据和页面渲染关联起来
    setTimeout(() => {
      vm.name = 'hello'
      // vm._update(vm._render()) // 重新调用render方法产生虚拟dom,暂时没有diff算法
    }, 2000);
    // vm.name = 'afeng'
    setTimeout(() => {
      vm.age.push(444)
      // vm._update(vm._render()) // 重新调用render方法产生虚拟dom,暂时没有diff算法
    }, 3000);
  </script>
</body>
</html>